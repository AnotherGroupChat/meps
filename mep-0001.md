---
MEP: 1
Title: Representation as a Python File
Discussion: XXX
Implementation: https://github.com/marimo-team/prototype/tree/file_v01
---

# Representation of an App as a Python File

## Abstract

This MEP proposes a representation of Marimo apps as structured Python files.
The representation is legible and easily versionable through source control. It
is designed to allow importing Marimo apps as Python modules, to access cells,
names, or the DAG itself, while also functioning as an executable script. We
strive for a minimal representation with these constraints in mind.

## Motivation

Marimo apps are dataflow programs, implemented in Python and executed by the
`marimo` Python library. It makes sense for these apps to be stored on disk as
Python files.

We seek a representation that is

- git (diff) friendly
- legible
  - cell order
  - cell names
  - cell refs and defs
  - dataflow structure
- usable as a Python module
  - for the server to load an app into the marimo frontend
  - for users to use ("remix") cells, names, or the entire graph in other
    Python programs
- executable as a Python script

## Example

Three cells, in a program called "numerics". Each cells can be understood
as a map between references and definitions ("refs" and "defs").


<table>
  <th>
  cell
  </th>
  <th>
  refs
  </th>
  <th>
  defs
  </th>

  <tr style="background:white">
  <td>

  ```python
  import marimo as mo
  import numpy as np
  ```
  </pre>
  </td>

  <td>
  {}
  </td>

  <td>
  {mo, np}
  </td>
  </td>
  </tr>

  <tr>
  <td>

  ```python
  def matmul(X, Y):
    return np.matmul(X, y)
  ```
  </td>

  <td>
  {np}
  </td>
  <td>
  {matmul}
  </td>
  </tr>


  <tr style="background:white">
  <td>

  ```python
  Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
  mo.md(f"You calculated {Z}")
  ```
  </td>

  <td>
  {matmul, mo, np}
  </td>
  <td>
  {Z}
  </td>
</table>

Saved to `numerics.py`:

```python
"""a marimo app

made with marimo v0.0.1
"""

import marimo


def _cells():
    def a():
        import marimo as mo
        import numpy as np
        return mo, np

    def b(np):
        def matmul(X, Y):
            return np.matmul(X, Y)
        return matmul,

    def c(matmul, mo, np):
        Z = matmul(np.random.randn(4, 4), np.random.randn(4, 4))
        mo.md(f"You calculated {Z}")
        return Z,

    return a, b, c


core = marimo.Core.from_functions(_cells())


def _main():
    cells = core._functions
    defs = {}
    defs['mo'], defs['np'] = cells.a()
    defs['matmul'], = cells.b(defs['np'])
    defs['Z'], = cells.c(defs['matmul'], defs['mo'], defs['np'])
    return defs


if __name__ == '__main__':
    _main()
```

## Specification

A marimo file contains two names that will be used either internally by
the marimo library, or by users:

- `core`: The only public facing attribute. The `core` object will be extended
  with methods and attributes that provide access to the app's cells & names.
  This object may also store data for internal use.
- `_cells_with_syntax_errors`: a tuple of
  - cell name (`str`)
  - cell index (`Number`)
  - cell contents (`str`)

  for each cell that has a syntax error. This attribute is optional, and only
  consumed internally.

### Organization
The module's code is organized in the following order:
- **Header.** A comment that includes the version number of the marimo library
  that was used to generate the module.
- **Core construction function.** An internal function that defines the cell functions
  and constructs the core.
- **Syntax errors.** A list of cells with syntax errors, included only when at
  least one cell has a syntax error.
- **Core definition.** Invocation to the core construction function.
- **Main**: A main function that executes the DAG and returns its defs, guarded by a `if __name__ == '__main__'` check.

### Cells
Cells are included in the module as functions, defined in `_cells()`.
A cell function is a mapping from the cell's refs, which it takes as arguments,
to its defs, which it returns.

The body of the cell (excluding the return statement) must be formatted in exactly
the same way that the user's code was formatted in the frontend.

### Core
The `core` object includes a member `_functions`, a list of the functions used
to construct the core. This is used by the library to instantiate the
module. **This member must remain in future versions to ensure backwards
compatibility.**

In the future the `core` object may be extended with public members, such
as a `main` method that executes the DAG and returns its outputs and defs, a
`code` object that provides access to defs (including functions, classes)
without computing the whole dag, and code transformation utilities (such as to
push refs such as imports down into a cell).

### Error Handling

A generated module must always be importable, even if it has errors, so that
the server can extract cell codes and load them into the editor.

There are two types of errors we handle.

**Cycles.**
A marimo dataflow graph with a cycle is ill-defined and cannot be executed.
For this reason, the generated `__main__` code raises an error if the program
has a cycle.

Cycles are documented in a comment. This comment is not used by `marimo`, and
is only provided for the user's benefit.

Example:

```python
"""a marimo app

made with marimo v0.0.1
"""

import marimo


def _cells():
    def one(y):
        x = y
        return x,

    def two(x):
        y = x
        return y,

    def three(b):
        a = b
        return a,

    def four(a):
        b = a
        return b,

    return one, two, three, four


core = marimo.Core.from_functions(_cells())


def _main():
    # the following cycles were detected:
    #    one-two
    #    three-four
    raise ValueError('This program has errors:'
        + '\n* at least one cycle among cells'
    )
    

if __name__ == '__main__':
    _main()
```

**Syntax errors.**
Cells with syntax errors cannot be defined as functions (if they were, importing
the module would raise a SyntaxError exception). Instead, they are included
in the file within an array of tuples. The tuples have the minimal information
needed for the editor to load them:
- the cell name
- the cell index/location
- the cell's function body, as a string, with double quotes escaped


Example:

```python
"""a marimo app

made with marimo v0.0.1
"""

import marimo


def _cells():
    def one():
        import numpy as np
        return np,

    def three():
        'all good'
        return

    return one, three


_cells_with_syntax_errors = [
    (
        'two',
        1,
        """
        _ error
        """,
    ),
    (
        'four',
        3,
        """
        _ another_error
        _ and \"\"\"another\"\"\"
        """,
    ),
]


core = marimo.Core.from_functions(_cells())


def _main():
    raise ValueError('This program has errors:'
        + '\n* at least one cell has a syntax error'
    )


if __name__ == '__main__':
    _main()
```

### Running as a script
Executing a marimo generated Python file as a script will execute the DAG. This
isn't really useful on its own, unless the DAG includes lots of print
statements -- but that would be an anti-pattern, since standard out and
standard error are de-emphasized in marimo.

It could be useful if the generated HTML was printed to standard out, but it's
not clear that the generated HTML is useful outside the marimo frontend.

It could also be useful if `names` or "refless defs" (defs that do not depend
on refs) were lifted and made optional parameters of the main program, and if
the DAG interacted with the user's filesystem (e.g., saving files to disk).

The `__name__` guarded section has some use as documentation of the DAG's
structure.

### Namespacing
The user can define two types of names:
- cell names
- all other names (a cell's "defs")

The specification takes care to avoid name clashes with user-defined names by
ensuring that user names are never added to the generated code's `globals`:

- cell names are encapsulated by defining them within
  a function `_construct_cells` and storing them in a namedtuple (`_cells`)
- a cell's definitions are encapsulated by storing their names in a top-level
  dict (`defs`)

### Extensibility
The file must always export a `core` object, that at minimum has a `_functions`
attribute.

Additional functionality can be added by adding additional members to this
`core` object.

### Backwards Compatibility
The file format is guaranteed to be backwards compatible in the following
sense: marimo will always be able to open modules generated by older versions
of marimo, because all it needs are the cell functions (`_core.functions`) and
syntax errors (`_cells_with_syntax_errors`).

Conversely, for as long as we only depend on these two names, marimo should be
forward compatible with modules generated by newer versions of marimo (i.e., 
an old version of marimo should be able to load a module generated by
a newer version).

The version of marimo used to generate the module is included in the header
in case a backward incompatible change is made. In this case, the version
of marimo that introduced the backward incompatible change should be bundled
with a loader that can read modules generated by older versions.

## Alternatives Considered

1. Decorating each function with `@marimo.cell`, which transforms functions into
   structured Cell objects. Because this transformation can be hidden away in
   marimo's internals, there was no good reason to do this.
2. A flat format in which the program was stored as a script, using comments
   to separate cells instead of encapsulating them in functions. This is
   a smaller representation than what we've proposed in this MEP, but it makes
   it unwieldy to use the script as a module.


## Implementation

https://github.com/marimo-team/prototype/tree/file_v01

## Future Considerations

- Invoking a marimo app as a script with optional parameters (substituting for some or all refless defs)
- Invoking `Core.main` with optional parameters (substituting for some or all refless defs)
